# 스케줄링

프로세스가 동작하는 일련의 행위를 **워크로드(workload)** 라고 한다. 이러한 워크로드들을 효율적으로 실행할 수 있도록 하는 **스케줄링 정책(scheduling policy)** 들에 대해 다루어 볼 것이다.

## 스케줄링 평가

스케줄링 정책이 얼마나 효율적인지 판단하기 위해 항목(metric)을 선정할 필요가 있다. 먼저 **반환 시간(turnaround time)** 이라는 기준을 사용할 것이다. 

반환 시간은 다음과 같다.

`반환 시간 = 완료 시간 - 도착 시간`

# 선입선출(FIFO)

첫 번째 알고리즘은 **선입선출(First In First Out, FIFO)** 이다. 또는 **선도착선처리(First Come First Served, FCFS)** 라고도 부른다. 

FIFO는 단순하고 구현하기 쉽다는 장점이 있다. 

A, B, C 프로세스가 거의 동시에 순서대로 도착하고 각각 10, 20, 30초 걸린다고 하였을 때 평균 반환 시간은 20초가 된다.

하지만 A가 100초, B와 C가 10초 걸린다고 하였을 때 뒤에 있는 프로세스들은 그저 기다릴 수 밖에 없기 때문에 비효율적인 처리를 하게 된다. 이러한 현상을 **convoy effect**라고 부른다.

# 최단 작업 우선(SJF)

앞에서의 convoy effect를 해결할 수 있는 방법이다. 이 방법은 **최단 작업 우선(Shortest Job First)** 으로, 이름에서 알 수 있듯이 처리 시간이 짧은 작업을 우선으로 실행하게 된다.

그렇다면 바로 위의 사례도 기존에는 평균 반환시간이 110초 였지만, SJF를 쓰면 50초로 줄어든 모습을 볼 수 있다.

하지만 아직 문제가 남아있는데, 만약 A가 처리되는 도중 나중에 B와 C가 오게 된다면 여전히 A가 끝날 때 까지 기다려야 한다.

# 최소 잔여시간 우선(STCF)

이제부터는 타이머 인터럽트가 발생하고, 문맥교환을 하게 된다. 기존의 방식들은 **비선점**형 스케줄링 방식이어서 이미 할당된 자원을 다른 프로세스가 강탈할 수 없었지만, **선점**형 스케줄링하게 될 경우 우선순위가 높은 프로세스를 먼저 처리할 수 있게 된다.

SJF에서 선점 기능이 추가된 방식은 최단 잔여시간 우선(Shortest Time-to-Completion First, STCF)이다. 이 스케줄러는 새로운 작업이 도착할 경우 이미 실행중인 프로세스와 비교하여 잔여시간이 더 짧은 프로세스를 우선 스케줄 한다.

# 응답 시간

작업의 길이를 알고, CPU만 사용하면서 반환 시간만 고려한다면 STCF가 좋은 스케줄러이다. 그러나 시분할 컴퓨터가 등장하면서 사용자가 터미널에서 작업하게 되었고 이에 따라 상호작용을 원활히 하기 위한 성능이 중요하게 되었다. 바로 **응답 시간(response time)** 이 중요해진 것이다.

`응답 시간 = 첫 실행 - 반환`

기존에 사용하고 있던 STCF를 생각해보면 응답 시간이 짧지 않다. 만약 사용자가 원하는 작업보다 다른 작업이 더 짧아 우선 실행 될 수도 있어 다른 작업이 끝나기를 기다려야만 한다. 그렇다면 다른 방법으로 이 문제를 해결할 필요가 있다.

# 라운드 로빈(RR)

응답 시간 문제를 해결 하기 위해 **라운드 로빈(Round Robin)** 스케줄링이 등장하게 되었다.

방식은 간단한데, 작업이 끝날 때 까지 기다리는 것이 아니라 일정 시간만 실행한 후 다음 작업으로 전환하는 것이다. 이 일정 시간을 **타임 슬라이스(time slice)** 혹은 **스케줄링 퀀텀(scheduling quantum)** 이라고 부른다.

이 RR에서 타임 슬라이스의 길이가 중요한데, 너무 짧으면 문맥 교환의 비용이 커지고 너무 길면 응답 시간이 길어지게 된다. 

또한 반환 시간을 고려해본다면 RR은 최악의 정책이 될 것이다. RR은 기본적으로 공정한 정책이므로 반환 시간에서는 성능이 나쁘다.
