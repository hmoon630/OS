# 완전한 가상 메모리 시스템

# VAX/VMS 가상 메모리

VMS는 컴퓨터의 구조적 결함을 소프트웨어로 보완한 훌륭한 사례다. 운영체제가 이상적인 개념과 환상을 제공하기 위해 하드웨어에 의존하지만 하드웨어가 모든 것을 해내지는 못한다. VAX 하드웨어에서 해당 사례들을 몇가지 보고, 결함에도 불구하고 시스템이 효과적으로 작동하기 위해 VMS OS가 한 일을 볼 것이다.

## 메모리 관리 하드웨어

VAX-11은 512 바이트 페이지 단위로 나눠진 32비트 가상 주소 공간을 제공한다. 가상 주소는 23비트 VPN과 9비트 오프셋으로 이루어져 있다. VPN 상위 두 비트는 페이지가 속한 세그멘트를 나타내기 위해 사용되었다. 즉 페이징과 세그멘테이션의 하이브리드 구조를 사용한 것이다.

프로세스 공간(주소 공간의 하위 절반) 의 첫번째 절반(P0)에 사용자의 코드와 힙이 존재한다. 그리고 나머지 절반(P1)은 스택이 존재한다. 주소 공간의 상위 절반은 그 중 반만 사용하며 시스템 공간(S)라 불린다. 운영체제의 보호된 코드와 데이터가 이 곳에 존재하게 된다.

VMS 설계자들의 주요 고민 중 하나는 VAX 하드웨어의 페이지 크기가 512바이트로 너무 작다는 것이었다. 이는 선형 페이지 테이블의 크기가 지나치게 커진다는 문제를 낳았다. 

이 시스템은 페이지 테이블로 인한 메모리 압박을 경감시키기 위해 두 가지 방법을 사용하였다.

첫째로 P0과 P1 두 개의 세그멘트로 나누면서 각자 페이지 테이블을 가지게 하였다. 스택과 힙 사이 사용되지 않은 주소 영역을 위한 페이지 테이블을 없앤 것이다. 

둘째로 OS가 사용자 페이지 테이블들을 커널의 가상 메모리에 배치하여 메모리 아박을 더 줄일 수 있었다. 페이지 테이블을 할당하거나 크기를 키울 떄 커널은 자신의 가상 메모리, 세그멘트 내에 공간을 할당한다. 메모리가 고갈되면 커넝른 페이지 테이블의 페이지들을 디스크로 스왑하여 물리 메모리를 다른 용도로 사용할 수 있게 한다.

## 실제 주소 공간

VMS 학습의 좋은 점은 실제 주소 공간의 구축 상황을 볼 수 있다는 것이다.

코드 세그멘트는 절대로 페이지 0에서 시작하지 않는다. 대신 접근 불가능 페이지로 마킹되어 있고 **널-포인터(null-pointer)** 접근을 검출할 수 있게 한다. 이는 효과적인 디버깅을 지원하기도 한다.

더 중요한 사실은 커널의 가상 주소 공간이 소용자의 주소 공간의 일부라는 것이다. 문맥 교환이 발생하면 OS는 P0과 P1 레지스터를 다음 실행될 프로세스의 페이지 테이블을 가리키도록 변경한다. 하지만 S베이스와 바운드 레지스터를 변경하지 않기 때문에 결과적으로 "동일한" 커널 구조들이 각 사용자 주소 공간에 매핑된다.

몇가지 이유로 커널은 여러 주소 공간들로 매핑된다. 그러한 구조를 택하면 커널이 동작이 쉬워진다.

OS가 프로그램으로부터 포인터를 전달 받았다면 그 포인터로부터 데이터를 자신의 구조로 복사하면 된다. 만약 커널이 전부 물리 메모리에만 존재한담녀 페이지 테이블의 페이지들을 디스크로 스오바하는 등의 작업이 어려웠을 것이다. 커널이 자체 주소 공간을 가졌다면 프로그램과 커널 간의 데이터 이동이 매우 복잡하고 어려웠을 것이다.

이 주소 공간에 관한 마지막 이슈는 보호와 관련 있다. VAX는 페이지 테이블의 protection bit에 보호 수준을 지정한다. 특정 페이지를 접근하기 위해서 CPU의 권한 수준이 기록 되는데, 시스템 데이터와 코드는 다른 것들보다 더 높은 보호 수준으로 지정된다. 만일 사용자 프로그램이 접근을 시도하면 트랩에 걸릴 것이다.

## 페이지 교체

VAX의 PTE는 다음과 같은 비트를 가지고 있다. **유효(valid)** 비트, **보호 필드**(**protection field**, 4비트), **변경**(**modify** 또는 **더티(dirty)**) 비트, 운영 체제가 사용하기 위해 예약해 놓은 비트(5비트), 그리고 **PFN**이 있다.

다만 **reference bit**는 없는데 VMS의 교체 알고리즘은 어떤 페이지가 자주 사용 중인지 하드웨어 지원 없이 판단해야한다.

개발자들은 **메모리 호그(memory hog)** 에 대해서도 고민하였다. 메모리 호그는 메모리를 너무 많이 사용하는 프로그램을 의미한다. 이를 문제들을 해결하기 위해 **세그멘트된 FIFO** 교체 정책을 제안하였다.

각 프로세스는 **상주 집합 크기(resident set size, RSS)** 라고 불리는 메모리에 유지할 수 있는 최대 페이지 개수를 지정 받는다. 만약 페이지 개수가 이보다 커지면 제일 먼저 들어온 페이지가 쫓겨난다. 

순수 FIFO의 성능은 그리 좋지 못한데, 이를 개선하기 위해 VMS는 *전역 클린-페이지 프리 리스트(global clean-page free list)* 와 *더티-페이지 리스트(dirty-page list)* 라고 하는 **second-chance list**를 도입하였다.

이는 메모리에서 제거되기 전에 페이지가 보관되는 리스트이다. FIFO 리스트에서 제거된 페이지가 클린 상태라면 클린-페이지 리스트에, 더티 상태라면 더티-페이지 리스트에 추가된다. 다른 프로세스가 빈 페이지를 요청하면 클린 리스트에서 프리 페이지를 꺼낼 것이고 만약 원래 프로세스가 요청하면 다시 가져가서 사용하게 된다. 이 second-chance list의 크기가 커지면 LRU와 유사하게 동작하게 된다.

또 다른 최적화 기법으로 VMS의 작은 페이지 크기를 극복하게 하였다. 더티 리스트에 있는 페이지들을 작업 묶음을 만들어서 한번에 디스크로 보낸다.(그렇게하여 페이지를 클린 상태로 만든다.) 이 방법을 **클러스터링(clustering)** 이라 부른다. 이는 현대의 시스템에도 대부분 사용한다.

## 그 외 기법들

그 외에도 **요청시 0으로 채우기(demand zeroing)** 와 **쓰기-시-복사(copy-on-write)** 가 있다. 이 두가지의 **게으른(lazy)** 최적화 기법들을 설명한다.

**demand zeroing**은 힙에 페이지를 추가하는 요청이 오면 OS는 물리 메모리에서 페이지를 찾아 0으로 채운다.(이는 보안을 위해 중요하다.) 하지만 이 페이지를 사용하지 않는다면 너무 많은 비용을 지불한 것이 된다.

이를 방지하기 위해 주소 공간에 추가되는 시점에는 아무것도 하지 않다가 실제로 페이지를 읽거나 쓸 때 트랩이 발생하여 0으로 채운다. 이는 PTE의 "운영체제를 위해 예약된 비트"에 표시되어 있다. 프로세스가 접근하지 않는다면 이 모든 작업을 피할 수 있으며 이것이 demand zeroing의 장점이다.

또 다른 멋진 방법으로 **copy-on-write(COW)** 가 있다. 한 주소 공간에서 다른 공간으로 복사할 때 복사 하지 않고 해당 페이지를 대상 주소 공간으로 매핑하고 해당 페이지의 엔트리를 양쪽 주소공간에서 읽기 전용으로 표시한다. 양측에서 해당 페이지를 읽기만 한다면 더 이상 작업이 필요 없으며, 실제 데이터 이동 없이 빠르게 복사가 가능하다.

둘 중 하나가 쓰기를 시도한다면 트랩이 발생하고, OS는 COW 페이지임을 파악할 것이다. 그 후 새로운 공간을 할당하고 데이터를 복사하게 된다.

# Linux 가상 메모리 시스템

## Linux 주소 공간

다른 현대 OS와 마찬가지로 사용자 영역과 커널 부분으로 구성된다. 문맥 교환시 실행중인 주소 공간의 사용자 영역이 변경된다. 그리고 사용자 모드의 프로그램은 커널 가상 페이지에 접근할 수 없다.

32비트 Linux에서 주소 공간의 사용자와 커널 영역 사이의 분할은 주소 0xC0000000 또는 주소 공간의 3/4 지점에서 발생한다. 따라서 가상 주소 0에서 0xBFFFFFFF은 사용자 가상 주소 공간, 나머지 가상 주소 공간은 커널 가상 주소 공간이다. 64-비트 Linux도 유사하게 나누어지지만 경계 지점이 다르다. 

Linux의 흥미로운 점은 커널 가상 주소의 유형이 2개 라는 것이다. 하나는 **커널 논리 주소(kernel logical addresses)** 이다. 이것은 일반적으로 생각하는 커널의 가상 주소 공간이다. 이 유형의 메모리가 더 필요한 경우, 커널 코드는 kmalloc을 호출하기만 하면 된다. 페이지 테이블, 프로세스별 커널 스택 등과 같은 커널 데이터 구조가 모두 여기 있다. 다른 대부분의 메모리와 달리 커널 논리 메모리는 디스크로 스왑 할 수 없다.

커널 논리 주소는 물리 메모리의 첫 부분에 직접 매핑된다. 따라서 커널 논리 주소 0xC0000000은 물리 주소 0x00000000으로, 0xC0000FFF는 0x00000FFF로 매핑된다. 이는 논리 주소와 물리 주소 사이 변환이 간단하다는 점과 커널 논리 주소공간에서 연속적이면 물리 메모리에서도 연속적이라는 장점이 있다. 이러한 작업에는 **직접 메모리 접근 방식(direct memory access, DMA)** 을 사용해 장치와 메모리 사이에 입출력 전송을 하는 경우를 들 수 있다.

커널 주소의 다른 유형은 **커널 가상 주소(kernel virtual address)** 이다. 이 유형의 메모리를 얻으려면 커널 코드는 **vmalloc**을 호출한다. vmalloc은 원하는 크기의 가상 공간에서 연속적인 영역에 대한 포인터를 반환한다. 이러한 메모리는 더 쉽게 할당할 수 있기 때문에 연속된 물리 메모리 청크를 찾는 것이 어려운 대용량 버퍼 할당에 사용된다.

## 페이지 테이블 구조

x86은 다중 레벨 페이지 테이블 구조를 제공하여 프로세스 당 하나의 페이지 테이블이 있다. OS는 단지 메모리에 매핑을 설정하고 특권 레지스터가 PD의 시작 주소를 가리키게 하기만 하면 하드웨어가 그 이후의 모든 처리를 담당한다.

과거와 가장 큰 변화 중 하나는 32비트 x86에서 64비트 x86으로 넘어갔다는 것이다. 64비트 주소로 전환하면 x86의 페이지 테이블 구조가 영향을 받는다. 다중 레벨 페이지 테입르을 사용하므로 64비트 시스템은 4레벨 테이블을 사용한다. 그러나 전체 64비트 크기의 전체 가상 주소 공간이 사용되지 않고 하위 48비트만 사용한다.

## 크기가 큰 페이지 지원

Intel x86은 여러 페이지 크기를 사용할 수 있따. 최근의 설계는 2MB 심지어 1GB 페이지도 하드웨어로 지원한다. 시간이 지남에 따라 Linux는 거대한 페이지를 사용할 수 있도록 진화하였다.

거대한 페이지를 사용하면 페이지 테이블에 필요한 매핑 개수가 줄어들고 TLB가 더 효과적으로 작동하여 그에 따른 성능의 이득이 크다. 많은 양의 메모리를 적극적으로 사용하여 TLB의 미스가 줄어들게 된다. 일부 응용프로그램은 TLB 미스를 처리하는데 자신의 CPU 사이클의 10퍼를 소비한다고도 하니 이는 큰 이득이다.

거대한 페이지에 대한 지원은 점진적으로 이루어졌다. 처음에 Linux 개발자들은 대규모 데이터베이스와 같은 몇몇 응용프로그램에게만 mmap() 또는 shmget() 호출을 통해 명시적으로 큰 크기의 페이지를 할당할 수 있도록 결정하였다. 그러나 최근 들어 응용프로그램들이 TLB를 더 효과적으로 사용할 수 있도록 **투명한(transparent)** 거대한 페이지 지원을 추가하였다.

거대한 페이지를 사용하는데에는 대가가 있다. 가장 큰 비용은 **내부 단편화**이고, 스와핑도 제대로 작동하지 않으며 I/O양을 크게 증가 시킬 수 있다.

## 페이지 캐시

대부분의 시스템은 영구 저장장치에 대한 접근 비용을 줄이기 위해 공격적인 **캐싱** 서브시스템을 사용하여 메모리에 유지한다. 리눅스도 크게 다르지 않다.

Linux **페이지 캐시(page cache)** 는 3가지 소스로부터 온 페이지를 메모리에 유지하도록 통합한다. **메모리 맵 파일(memory-mapped files)**, 파일 데이터와 장치의 메타데이터, 힙과 각 프로세스를 구성하는 스택 페이지 이다. 이러한 개체들은 **페이지 캐시 해시 테이블(page cache hash table)** 에 보관 되므로 데이터 필요할 때 빠른 검색이 가능하다.

페이지 캐시는 항목이 **클린**인지 **더티**인지 추적한다. 더티 데이터는 pdflush에 의해 백킹 스토어에 주기적으로 기록되어 갱신된 데이터가 결국 영구 저장 장치에 다시 기록되게 한다. 이 활동은 일정 시간이 경과하거나 너무 많은 페이지가 더티로 분류되면 일어난다. 이들은 매개 변수로 설정 가능하다.

리눅스는 메모리 확보를 위해 2Q 교체 알고리즘의 변형된 형태를 사용한다. 기본적으로 LRU 교체 알고리즘이 효과적이지만 특정 액세스 패턴에 대해서는 효과가 반전될 수 있다.

2Q 교체 알고리즘의 Linux 버전은 두 개의 리스트를 유지하여 메모리를 두 부분으로 나누어서 이 문제를 해결한다. 처음 액세스 되면 페이지는 **비활동 리스트(inactive list)** 로 들어간다. 다시 참조되면 **활동 리스트(active list)** 로 승격된다. 교체 후보는 inactive list에서 가져온다. 또한 Linux는 활성 리스트의 맨 아래 페이지를 비활성 리스트로 이동 시켜 활동 리스트의 길이가 총 페이지 캐시 크기의 약 2/3가 되도록 유지한다.

이상적으로 완벽한 LRU 순서가 되도록 이 리스트를 관리하려고 했겠지만 이렇게 하려면 많은 비용을 지불해야 한다.

## 보안과 버퍼 오버플로우 공격

Linux에서 주요 위협 중 하나는 **버퍼 오버 플로(buffer overflow)** 공격으로서 보통의 사용자 프로그램이나 심지어 커널 자체를 대상으로 사용될 수 있다. 이 공격의 아이디어는 공격자가 목표 시스템의 주소 공간에 임의의 데이터를 주입할 수 있는 버그를 찾는 것이다. 만약 너무 긴 입력을 아무런 의심 없이 버퍼에 복사하다가 버퍼의 경계를 넘어 목표의 메모리를 덮어 쓸 수 있다. 대부분의 경우 오버 플로우는 치명적이지 않지만 악의를 가지고 버퍼를 오버플로우 하는 일은 코드를 주입 시켜 시스템을 장악할 수 있다.

버퍼 오버플로를 막는 가장 단순한 방어로, 특정 영역에 탑재된 코드는 실행할 수 없도록 만드는 것이다. AMD가 x86버전에 도입한 **NX 비트(No-eXecute)** 가 그 방어 중 하나이다.
