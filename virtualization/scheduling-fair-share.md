# 공정 배분

**공정 배분(fair share)** 혹은 **비례 배분(proportional share)** 이라고 불리는 스케줄링 방식은 각 작업에게 CPU의 일정 비율을 보장하는 것이 목적이다.

또한 프로세스, 유저, 그룹 레벨로 공정하게 CPU 자원을 RR 방식으로 배분할 때에도 사용할 수 있다.

# 추첨 스케줄링(lottery scheduling)

굉장히 단순하고 오래된 아이디어 중 하나인 **추첨 스케줄링**은 이름에서 알 수 있듯이 추첨을 통해 실행할 프로세스를 정한다.

**추첨권**이 가장 기본이 되는 개념인데, 추첨권을 가진 비율이 곧 자원이 할당될 몫을 의미한다. 예를 들어 A 프로세스가 75장의 추첨권을, B 프로세스가 25장의 추첨권을 가진다면 두 프로세스가 할당받을 자원의 양을 75%, 25%를 할당하는 것이 목적이라고 할 수 있다.

추첨 스케줄링은 타임 슬라이스가 끝날 때 마다 추첨하는데, 스케줄러가 추첨권의 전체 갯수를 파악한 다음 랜덤으로 추첨한다. 무작위성 때문에 정확히 보장하지는 못하지만 실행이 길어질 수록 원하는 비율에 달할 가능성이 높다.

# 보폭 스케줄링(stride scheduling)

추첨 스케줄링은 무작위성에 의해 정확한 비율을 보장받지 못했지만, 결정론적인 공정 배분 방식인 **보폭 스케줄링(stride scheduling)** 은 그 문제를 해결하였다.

A, B, C가 추첨권을 100, 50, 250을 갖고 있다고 했을 때 임의의 큰 값을 각장의 추첨권 개수로 나누면 각 작업의 **보폭(stride)** 이 나온다. 10000을 추첨권의 갯수로 나누면 각각 보폭은 100, 200, 40이 된다.(추첨권의 갯수와 반비례 하게 된다.) 

이제 각 프로세스가 실행될 때 **pass**라는 값을 각 보폭만큼 증가시켜서 CPU를 얼마나 사용하였는지 추적한다.

스케줄러가 어떤 프로세스를 실행시킬지 선택하는 방법은 간단하다.

1. 가장 작은 pass값을 가진 프로세스를 선택한다.
2. 타임슬라이스만큼 실행하고 pass에 보폭 값을 더한다.

이 방법대로 진행하면 정확한 비율로 CPU를 배분할 수 있다.

하지만 보폭 스케줄링에도 문제가 있는데, 만약 새로운 프로세스가 도착했을 때 pass의 값이 얼마가 되어야 하는가이다. 만약 0이 되면 CPU를 독점하게 될것이다. 하지만 추첨 스케줄링은 보폭 스케줄링과 다르게 상태 값이 필요없기 때문에 새로운 프로세스를 추가하는데에 있어서는 추첨 스케줄링이 유리하다.

# 리눅스 CFS(Completely Fair Scheduler)

현재 Linux는 기존과 다른 방식의 공정 배분 스케줄링을 구현하였다. **Completely Fair Scheduler** 이다. 이 스케줄러의 장점은 효율성과 확장성이다.

대부분 스케줄러들은 고정된 길이의 타임슬라이스를 사용하는데, CFS는 모든 프로세스에게 CPU를 공정하게 할당하는 것이 목표이기 때문에 **virtual runtime(vruntime)** 이라는 간단한 카운팅 테크닉을 사용한다.

프로세스가 실행되면 스케줄러는 프로세서의 vruntime 값을 누적 시킨다. vruntime은 실제 시간과 같은 속도로 증가하고, 스케줄러는 가장 낮은 vruntime을 가진 프로세스를 다음에 실행할 프로세스로 선택한다.

스케줄러를 얼마나 자주 실행할 지는 *sched_latency*에 의해 결정된다. 이 값은 프로세스가 한번 실행된 후 다음번에 cpu를 사용할 수 있을 때 까지의 최대 시간을 나타낸다. 보통 *sched_latency*는 48ms이다. CFS는 타임 슬라이스를 `sched_latency / 프로세스 갯수 (n)`으로 나누어 계산한다. 4개의 경우에는 타임 슬라이스가 12ms가 되는 것이다.

만약 너무 많은 프로세스가 실행 중이라면 타임 슬라이스의 크기가 작아질 것이고 문맥 교환이 더 자주 일어나 오버헤드가 커질 것이다. 그것을 해결하기 위해 **min_granularity**가 존재하는데, 최소값으로 보통 6ms로 설정되어 있다. 비록 sched_latency의 보장은 어려워지더라도 스케줄링은 더욱 효율적이 되고, CPU를 공정하게 배분하는 데에는 문제가 없다.

## 가중치 (Niceness)

CFS는 사용자나 관리자가 프로세스의 우선 순위를 조정하여 다른 프로세스보다 CPU 시간을 더 할당 받게 할 수 있다. nice 레벨이라는 -20부터 19까지 설정 가능한 값을 사용한다. 값이 양수이면 낮은 우선순위를 의미하고 음수이면 높은 우선순위를 의미한다.

이 가중치는 실질적인 타임 슬라이스를 계산하는데 사용된다. 가중치가 작으면 타임 슬라이스를 그만큼 더 할당 받고, 가중치가 크다면 타임 슬라이스를 더 적게 할당받는다.

또한 *runtime*을 계산 하는데에도 가중치가 반영될 수 있는데, 가중치가 작으면 그만큼 느린 속도로 runtime이 증가한다.

가중치 표의 장점은 nice 값의 차이가 같으면 CPU 배분 비율도 같다는 것이다. 예를 들어 A와 B 프로세스가 각각 -5, 0의 nice를 가지는 것과 5, 10의 nice를 가지는 것은 둘 경우 다 같은 CPU 배분 비율을 가진다.

## Red-Black 트리 활용

CFS의 핵심은 알고리즘 효율성이다. 효율적인 알고리즘을 이용해 빠르게 스케줄링 하는 것이 매우 중요하다. 대기 중인 프로세스 관리를 위해 구현이 쉬운 링크드 리스트를 활용할 수도 있겠지만, 가장 작은 vruntime을 가진 프로세스를 찾기 위해 탐색할 때에는 굉장히 오래 걸릴 것이다.

CFS는 프로세스 관리에 red-black 트리를 사용하여 효율성 문제를 해결하였다. red-black 트리는 이진 탐색 트리, 균형 트리의 일종으로 depth를 일정하게 유지하고, 탐색, 삽입, 삭제 연산이 O(logN) 시간 복잡도를 가진다.

CFS가 모든 프로세스를 red-black 트리로 관리하는 것은 아니고, 실행 중이거나 실행 가능한 프로세스들만 이 구조에 보관하게 된다. 프로세스가 sleep상태에 들어가면 트리에서 제거되고 다른 곳에 보관된다.

## 잠자는 프로세스 다루기

장시간 잠들어 있던 프로세스는 vruntime이 다른 프로세스에 비해 뒤쳐질 것이다. 이 상태로 스케줄링 할 경우 프로세스가 CPU를 독점하여 다른 프로세스가 기아 상태에 빠질 것이다.

이를 위해 CFS는 적절한 vruntime을 부여하게 되는데 트리에 있는 vruntime중 가장 작은 vruntime 값으로 설정하게 된다. 이렇게 하면 큰 오버헤드 없이 기아 현상을 방지할 수 있다. 다만 자주 잠자기에 들어가는 작업의 경우 CPU 배분에 있어서 손해를 보게된다.
